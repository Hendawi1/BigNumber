# Подробный рапорт (write-up) по проекту: реализация класса `BigNumber` для работы с большими числами

**Язык рапорта:** русский

---

## Содержание

1. Аннотация и актуальность проекта
2. Введение в системы счисления — теоретические основы
3. Выбор системы счисления для `BigNumber` и мотивация (base-256)
4. Структура класса `BigNumber` — обзор API и полей
5. Подробное описание конструкторов и служебных методов
6. Операторы сравнения и присваивания — логика и реализация
7. Арифметические операции с `BASE` (байт) — математическая основа и реализация
8. Арифметические операции `BigNumber` ↔ `BigNumber` — алгоритмы, примеры и детали
9. Алгоритм деления (алгоритм Кнута) — полный пошаговый разбор
10. Ввод/вывод: hex и decimal — методы и замечания по эффективности
11. Граничные случаи и обработка ошибок
12. Сложность алгоритмов (временная и пространственная)
13. Тестирование и валидация
14. Заключение

---

## 1. Аннотация и актуальность проекта

В современном программировании стандартные целочисленные типы (`int`, `long`, `long long`) ограничены фиксированным числом бит. Это ограничение мешает решать ряд задач, где требуется работа с целыми числами произвольной длины: криптография (RSA, ECC), научные вычисления (потребность в высокой точности), компьютерная алгебра, финансовые расчёты и образовательные проекты по численным методам.

Проект реализует класс `BigNumber` в C++ — учебную и практичную реализацию длинной арифметики, позволяющую хранить числа больше, чем диапазон стандартных типов, и выполнять над ними стандартные арифметические операции: сравнение, сложение, вычитание, умножение, деление, взятие остатка, ввод/вывод в hex и decimal.

---

## 2. Введение в системы счисления — теоретические основы

### 2.1. Позиционные системы счисления

Позиционная система задаётся основанием (b) и цифрами (d_i) (0 ≤ (d_i) < (b)). Любое целое неотрицательное число представимо как

[
N = d_0 + d_1 b + d_2 b^2 + \dots + d_{n-1} b^{n-1}
]

где (d_0) — младший «разряд», (d_{n-1}) — старший.

### 2.2. Свойства, важные для реализации больших чисел

* **Основание**: выбор (b) определяет плотность хранения и простоту операций с переносом. Часто выбирают степень двух (2⁸, 2¹⁶, 2³²).
* **Порядок хранения (endianness)**: используем little-endian — младшие лимбы в начале вектора, что упрощает итерационные алгоритмы сложения/умножения.
* **Промежуточный тип (double-word)** нужен, чтобы хранить суммы и произведения двух лимбов без переполнения.
* **Удаление ведущих нулей (trim)** обеспечивает корректность сравнения длин чисел.

---

## 3. Выбор системы счисления для `BigNumber` и мотивация (base-256)

В реализации:

* `typedef unsigned char BASE;` — лимб = 8 бит;
* `typedef unsigned short DBASE;` — двойной тип = 16 бит;
* `BASENUM = (DBASE)1 << BASE_SIZE = 256`.

**Почему base-256:**

1. Экономно по памяти: 1 лимб = 1 байт.
2. Легко сериализовать/интерпретировать бинарные данные по байтам.
3. Произведение двух лимбов (<= 255×255 = 65025) помещается в 16 бит (`DBASE`), что делает операции безопасными.
4. Совместимость с архитектурой и простота реализации переносов (`>> BASE_SIZE`).
5. Little-endian хранение упрощает пошаговые операции от младших к старшим лимбам.

**Представление вектора `coefs`:**
`coefs[0]` — младший байт (256⁰), `coefs[n-1]` — старший. Trim удаляет ведущие нули, оставляя по крайней мере один лимб (для нуля — один нулевой лимб).

---

## 4. Структура класса `BigNumber` — обзор API и полей

Класс `BigNumber` хранит данные в `vector<BASE> coefs;` и предоставляет:

* Конструкторы:
  * `BigNumber()` — ноль
  * `BigNumber(unsigned int len)` — случайное число длины len
  * `BigNumber(string&)` — парсинг hex-строки
  * `BigNumber(const BigNumber&)` — копирующий конструктор

* Операторы сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`.

* Операции с маленьким операндом `BASE`:
  `+`, `-`, `*`, `/`, `%` и соответствующие compound-операторы.

* Операции `BigNumber` ↔ `BigNumber`: `+`, `-`, `*`, `/`, `%` и compound.

* Ввод/вывод:
  * `void OutputHex();` — вывод hex
  * `void InputHex();` — ввод hex
  * `ostream& operator<<`, `istream& operator>>` — decimal I/O

* Вспомогательные методы:
  * `BigNumber Shift(int bits);` — сдвиг по лимбам (умножение на 256^bits)
  * `void PrintBase256();` — печать внутреннего представления (debug)
  * `unsigned int getLength() const;` — длина в лимбах

---

## 5. Подробное описание конструкторов и служебных методов

### 5.1. `BigNumber::BigNumber()`

Инициализация одним нулевым лимбом:

```cpp
BigNumber::BigNumber() {
    coefs.push_back(0);
}
```

### 5.2. `BigNumber::BigNumber(unsigned int len)`

Генерация случайного числа:

```cpp
BigNumber::BigNumber(unsigned int len){
    if (!len) return;

    for (int i = 0; i < len-1; i++)
        coefs.push_back(rand());
    BASE coef = rand();
    while (!coef) coef = rand();
    coefs.push_back(coef);
}
```

### 5.3. `BigNumber::BigNumber(string& numInHex)`

Парсинг hex-строки. Принцип: читаем справа налево, собираем 4-битные куски и формируем байты.
Ключевые моменты:

* Поддерживается `[0-9a-fA-F]`.
* Используется `bitset<BASE_SIZE>` (8 бит) как временный аккумулятор.
* При накоплении 8 бит пушим байт в `coefs`.
* В конце trim: удаление ведущих нулей.

### 5.4. `BigNumber::BigNumber(const BigNumber& other)`

Копирующий конструктор: копирует вектор `coefs = other.coefs`.

### 5.5. `void BigNumber::OutputHex()`

Вывод в hex, старший байт без ведущих нулей, остальные с width=2 и fill='0'. В конце восстанавливается десятичный режим вывода.

### 5.6. `void BigNumber::InputHex()`

Просто запрашивает строку и вызывает конструктор `BigNumber(string&)`.

### 5.7. `void BigNumber::PrintBase256()`

Для отладки печатает лимбы в десятичном представлении: удобно смотреть внутреннее состояние.

### 5.8. `BigNumber Shift(int bits)`

В исходном коде объявлен, но не показана реализация. Ожидаемая реализация:

* Если `bits >= 0` и представляет число лимбов, то это умножение на (256^{bits}) — нужно вставить `bits` нулевых лимбов в начало vector.

---

## 6. Операторы сравнения и присваивания — логика и реализация

### 6.1. Цель и требования

**Цель** операторов сравнения — позволить корректно определить относительные величины больших чисел, представленных в виде массива лимбов (байтов). Операторы должны удовлетворять логике числовых сравнений: транзитивность, антисимметрия и т.д. Кроме того, присваивание должно корректно копировать представление, защищая от самоприсваивания и избегая некорректных состояний.

### 6.2. Внутреннее представление

* `coefs` — `vector<BASE>`, где `BASE` = `unsigned char` (8 бит).
* Little-endian: `coefs[0]` — младший лимб (256⁰), `coefs[n-1]` — старший лимб.
* invariant: после большинства операций вектор должен быть "trimmed": не иметь ведущих нулей, за исключением единственного нулевого лимба для числа 0.

### 6.3. `operator==` и `operator!=`

**Логика (математически)**

* Два числа равны тогда и только тогда, когда у них одинаковое количество значимых лимбов и значения каждого лимба на соответствующих позициях равны.
* Формально: `A == B` ⇔ `len(A) == len(B) ∧ ∀ i ∈ [0..len-1]: A.coefs[i] == B.coefs[i]`.

**Имплементация**

1. Убедиться, что оба числа находятся в нормальном виде: отсутствуют ведущие нули.
2. Сравнить размеры векторов: если `coefs.size() != other.coefs.size()` — вернуть `false`.
3. Иначе выполнить поэлементное сравнение: итерируем i от 0 до `len-1`. Если находим первое различие — вернуть `false`.
4. Если разницы не найдено — вернуть `true`.

### 6.4. `operator >` и `operator <`

**Математическая логика**

Сравнение двух натуральных чисел в positional system:

* Сначала сравниваем старший значимый разряд (количество разрядов). Большее количество значимых разрядов ⇒ большее число.
* Если длины равны, сравниваем последовательность лимбов от старшего к младшему — первый разряд, в котором значения различаются, определяет результат.

**Пошаговая реализация `operator>`**

1. Выполнить trim для обоих чисел.
2. `len_l = coefs.size()`, `len_r = other.coefs.size()`.
3. Если `len_l > len_r` — вернуть `true`.
4. Если `len_l < len_r` — вернуть `false`.
5. Иначе (len равны) — итерируем `i` от `len_l - 1` down to `0`:
   * Если `coefs[i] > other.coefs[i]` — вернуть `true`.
   * Если `coefs[i] < other.coefs[i]` — вернуть `false`.
6. Если цикл закончился без найденного различия — вернуть `false` (числа равны).

### 6.5. `operator<=`, `operator>=` — композиция

* `<=` реализуем как `!(*this > other)`.
* `>=` реализуем как `!(*this < other)`.
  Это даёт корректную экономную реализацию без дублирования кода.

### 6.6. `operator=` (присваивание)

**Цели**

* Скопировать состояние `other` в `this`.
* Избежать утечек/неинициализированного состояния.
* Защититься от самоприсваивания.

**Пошаговая реализация**

1. Проверка `if (this == &other)`. Если указатели равны — ничего не делать.
2. Очистить текущий `coefs` (`coefs.clear();`) или использовать `coefs = other.coefs;`.
3. Вернуть `*this` для цепочек присваивания.

---

## 7. Арифметические операции с BASE (байт) — математическая основа и реализация

В этом разделе разбираются арифметические операции, где один из операндов — маленький тип `BASE` (байт). Рассматриваются внутренние арифметические шаги, переносы/заёмы, границы и все промежуточные значения.

> Общая установка: `BASE` — одноразрядная "цифра" в базе (b = 256). `DBASE` — двойной тип (16 бит) для аккумулирования сумм и произведений.

### 7.1. Базовая математика: почему используется DBASE

* При сложении лимба и переносa возможен перенос до `b-1 + b-1 + carry = 255 + 255 + 1 = 511`, что требует ≥ 9 бит.
* При умножении: `255 * 255 = 65025` — это ≤ 16 бит.
* Поэтому для промежуточных сумм/произведений нужен тип шире, чем `BASE` — `DBASE` (16 бит).

### 7.2. Операция `operator+ (const BASE& num)` — сложение с маленьким числом

**Цель**

Добавить маленькое значение `num` (0..255) к большому числу `A`.

**Десятичная аналогия (интуиция)**

Если у нас число в десятичной системе (цифры `d0, d1, ...`) и мы добавляем `x` в диапазоне 0..9, то:

* Прибавляем `x` к `d0`, получаем `tmp`, записываем `tmp % 10` и перенос `tmp / 10` в следующий разряд, и т.д.

**Реализация в base-256 (пошагово)**

1. `res = *this` — работаем с копией, чтобы не портить исходник.
2. `DBASE carry = num;` — начальный перенос равен прибавляемому значению.
3. Итерируем `i` от 0 до `res.coefs.size() - 1` пока `carry > 0`:
   * `DBASE tmp = DBASE(res.coefs[i]) + carry;`
   * `res.coefs[i] = BASE(tmp & 0xFF);` (в C++ это `BASE(tmp)`)
   * `carry = tmp >> BASE_SIZE;` (сдвиг на 8 бит, т.е. `tmp / 256`)
4. Если после цикла `carry > 0` — `res.coefs.push_back(BASE(carry));`
5. Выполнить `trim()` (удалить ведущие нули, если возникли).
6. Вернуть `res`.

**Конкретный числовой пример**

A = `[0xFF]` (255). num = `2`.

* i=0: tmp = 255 + 2 = 257 → res[0] = 1 (257 mod 256), carry = 1
* после цикла: carry=1 → добавляем res[1]=1 → число `[1,1]` => 1*256 + 1 = 257. OK.

### 7.3. `operator+= (const BASE&)` — компаунд

* Реализация: `*this = *this + num; return *this;`

### 7.4. `operator- (const BASE& num)` — вычитание маленького числа

**Цель**

Отнять `num` (0..255) от `A`. Если результат отрицательный — бросить исключение.

**Интуиция (десятичная)**

При вычитании `x` из числа `1234`: начинаем с `d0 - x`, если отрицательно — заём из следующей позиции.

**Реализация в base-256 (пошагово)**

1. Проверка: если `A` меньше `num` (т.е. `coefs.size() == 1 && coefs[0] < num`) — бросить `std::underflow_error`.
2. `res = *this; DBASE borrow = num;`
3. Итерировать `i` от 0 до `res.coefs.size()-1` пока `borrow > 0`:
   * `DBASE tmp = DBASE(res.coefs[i]) + BASENUM - borrow;` (предварительное сложение на `BASENUM = 256` устраняет отрицательные значения)
   * `res.coefs[i] = BASE(tmp & 0xFF);`
   * `borrow = 1 - (tmp >> BASE_SIZE);`
4. После окончания — `trim()` и вернуть `res`.

**Пример**

A = `[0x00, 0x01]` (256). num = `1`.

* i=0: tmp = 0 + 256 - 1 = 255 → res[0] = 255 (0xFF) ; borrow = 1 - (255 >> 8) = 1 - 0 = 1
* i=1: tmp = 1 + 256 - 1 = 256 → res[1] = 0 (256 mod 256) ; borrow = 1 - (256 >> 8) = 1 - 1 = 0
* result: `[0xFF, 0x00]` → trim removes high zero → `[0xFF]` = 255. Correct.

### 7.5. `operator* (const BASE& num)` — умножение на маленькое число

**Цель**

Умножить большое число `A` на одиночный лимб `num`.

**Математическая логика**

Школьное умножение: каждую цифру умножаем на `num` и учитываем перенос.

**Пошаговая реализация**

1. Если `A` равен нулю — вернуть ноль.
2. `BigNumber res; res.coefs.clear(); DBASE carry = 0;`
3. Для `i` от 0 до `len-1`:
   * `DBASE prod = DBASE(coefs[i]) * DBASE(num) + carry;`
   * `res.coefs.push_back( BASE(prod & 0xFF) );`
   * `carry = prod >> BASE_SIZE;` (`prod / 256`)
4. После цикла, если `carry != 0` — пушим `BASE(carry)`.
5. Trim и вернуть `res`.

**Пример**

A = `[0x10, 0x02]` = 2*256 + 16 = 528. num = 3.

* i=0: prod = 16*3 + 0 = 48 → res[0] = 48 ; carry = 0
* i=1: prod = 2*3 + 0 = 6 → res[1] = 6 ; carry = 0
* result `[48,6]` = 6*256 + 48 = 1568 = 528 * 3. OK.

### 7.6. `operator/ (const BASE& num)` — деление на маленький делитель

**Цель**

Разделить `A` на целое `num` (1..255), вернуть частное; остаток вычисляется отдельным оператором `%`.

**Логика (вручную)**

Деление идёт с верхних (старших) лимбов к младшим: перенос (остаток) "сносим" вниз.

**Пошаговая реализация**

1. Если `num == 0` — бросать/обрабатывать ошибку (в текущем коде `exit(-3)`).
2. `BigNumber res; res.coefs.resize(len, 0);`
3. Инициализировать `DBASE tmp = 0; BASE r = 0;`
4. Для `j` от 0 до `len-1`:
   * `tmp = ((DBASE)r << BASE_SIZE) + DBASE(coefs[len - 1 - j]);`
     (мы поднимаем старший остаток r в старшие биты и добавляем текущий лимб)
   * `res.coefs[len - 1 - j] = BASE(tmp / DBASE(num));`
   * `r = BASE(tmp % DBASE(num));`
5. В конце `res.trim()` и вернуть.

### 7.7. `operator% (const BASE& num)` — остаток от деления

* Вариант реализации использует те же вычисления, что и деление, но возвращает `BigNumber` с одним лимбом равным `r` (остатку).
* Пошагово: пройти от старшего лимба, аккумулируя `r = ((r << 8) + coefs[i]) % num`.

---

## 8. Арифметические операции BigNumber ↔ BigNumber — алгоритмы, примеры и детали

В этом разделе разбираются операции, где оба операнда — большие числа (`BigNumber`). Для каждой операции дается: математическая идея, подробные пошаговые вычисления, псевдокод, примеры, и обсуждение пограничных случаев и сложности.

### 8.1. Сложение BigNumber + BigNumber

**Математическая идея**

Аналог школьного сложения в базе (b = 256): поразрядно складываем соответствующие лимбы с переносом.

Если числа имеют разную длину, недостающие лимбы считаются нулями.

**Формальный псевдокод**

```cpp
BigNumber add(BigNumber A, BigNumber B):
    trim(A); trim(B);
    n = max(len(A), len(B))
    carry = 0
    res = BigNumber()
    for i = 0 .. n-1:
        a = (i < len(A)) ? A.coefs[i] : 0
        b = (i < len(B)) ? B.coefs[i] : 0
        tmp = DBASE(a) + DBASE(b) + carry
        res.coefs.push_back( BASE(tmp & 0xFF) )
        carry = tmp >> 8
    if carry != 0:
        res.coefs.push_back(BASE(carry))
    res.trim()
    return res
```

**Пошаговый пример**

A = `0x01 00 FF` (в списке `[0xFF, 0x00, 0x01]`), B = `0x02 01 01` (`[0x01, 0x01, 0x02]`)

* i=0: tmp = 0xFF + 0x01 + 0 = 256 → res[0] = 0x00 ; carry = 1
* i=1: tmp = 0x00 + 0x01 + 1 = 2 → res[1] = 0x02 ; carry = 0
* i=2: tmp = 0x01 + 0x02 + 0 = 3 → res[2] = 0x03 ; carry = 0
  Результат: `[0x00,0x02,0x03]` => hex `0x030200`.

**Сложность**

* Время: O(n), n = max(len(A), len(B)).
* Память: O(n+1) для результата.

### 8.2. Вычитание BigNumber - BigNumber

**Математическая идея**

Школьное вычитание с заёмом. Предполагается, что `A >= B` (если нет — выбрасываем исключение или обрабатываем sign).

**Псевдокод**

```cpp
BigNumber sub(BigNumber A, BigNumber B):
    trim(A); trim(B)
    if A < B: throw underflow
    borrow = 0
    res = BigNumber()
    for i = 0 .. len(A)-1:
        a = A.coefs[i]
        b = (i < len(B)) ? B.coefs[i] : 0
        tmp = DBASE(a) + BASENUM - DBASE(b) - borrow
        res.coefs.push_back( BASE(tmp & 0xFF) )
        borrow = 1 - (tmp >> 8)
    res.trim()
    return res
```

**Пошаговый пример**

A = `[0x00,0x01]` (256), B = `[0x01]` (1)

* i=0: tmp = 0 + 256 - 1 - 0 = 255 → res[0] = 255 ; borrow = 1 - (255 >> 8) = 1
* i=1: a = 1; b = 0; tmp = 1 + 256 - 0 - 1 = 256 → res[1] = 0 ; borrow = 1 - (256 >> 8) = 0
  Result `[255, 0]` -> trim to `[255]` = 255.

**Пограничные случаи**

* Если `A == B` — возвращаем `0` (предварительно создавать один нулевой лимб).
* Если `A < B` — выбрасываем `underflow_error`.
* Если B длиннее A (но A>=B логически), принимаем недостающие лимбы B как 0 (ошибка только при A<B).

**Сложность**

* O(n), n = len(A).

### 8.3. Умножение BigNumber * BigNumber (школьный алгоритм)

**Математическая идея**

Для каждого лимба j второго множителя умножаем весь первый множитель, смещая результат на j позиций, аккумулируем в `res`. Это стандартный long multiplication.

**Псевдокод (детально)**

```cpp
BigNumber mul(BigNumber A, BigNumber B):
    trim(A); trim(B)
    if A == 0 or B == 0: return BigNumber(0)
    lenA = len(A); lenB = len(B)
    res_len = lenA + lenB
    res.coefs = vector<BASE>(res_len, 0)
    for j in 0 .. lenB-1:
        if B.coefs[j] == 0: continue
        carry = 0
        for i in 0 .. lenA-1:
            tmp = DBASE(A.coefs[i]) * DBASE(B.coefs[j]) + DBASE(res.coefs[i+j]) + DBASE(carry)
            res.coefs[i+j] = BASE(tmp & 0xFF)
            carry = tmp >> 8
        res.coefs[j + lenA] = BASE(carry)
    res.trim()
    return res
```

**Пошаговый пример (малые числа)**

A = `[0x02, 0x01]` = 1*256 + 2 = 258
B = `[0x03]` = 3

* j=0 (B[0] = 3):
  * i=0: tmp = 2*3 + res[0] + carry(0) = 6 → res[0] = 6 ; carry = 0
  * i=1: tmp = 1*3 + res[1] + carry = 3 → res[1] = 3 ; carry = 0
  * res[2] = carry = 0
    Result `[6,3]` = 3*258 = 774 → 3*256 + 6 = 774. OK.

**Сложность**

* O(lenA * lenB).

### 8.4. Деление BigNumber / BigNumber — подробный разбор

**Резюме алгоритма**

* Проверки частных случаев.
* Нормализация (умножение на d).
* Оценка пробного частного qhat по старшим лимбам.
* Коррекция qhat.
* Умножение v на qhat и вычитание.
* Повторение по всем позициям.

**Псевдокод (с акцентом на операции)**

```cpp
BigNumber div(BigNumber U, BigNumber V):
    trim(U); trim(V)
    if V == 0: throw error
    if len(V) == 1: return div_by_single(U, V.coefs[0])
    if U < V: return 0
    if U == V: return 1

    b = 256
    n = len(V)
    m = len(U) - n
    d = floor(b / (V.coefs[n-1] + 1))
    U = U * d
    V = V * d
    if len(U) == original_len(U_before)*? adjust -> ensure U has len >= n + m + 1
    q.coefs = zeros(m+1)

    for i = m down to 0:
        u2 = U.coefs[i+n]    // старший
        u1 = U.coefs[i+n-1]
        u0 = U.coefs[i+n-2]
        v1 = V.coefs[n-1]
        v2 = V.coefs[n-2]
        qhat = ((u2 << 8) + u1) / v1
        rhat = ((u2 << 8) + u1) % v1
        while qhat == b or qhat * v2 > (rhat << 8) + u0:
            qhat -= 1
            rhat += v1
            if rhat >= b: break
        t = V * qhat
        t = t.Shift(i)
        if U < t:
            qhat -= 1
            t = V * qhat
            t = t.Shift(i)
        U = U - t
        q.coefs[i] = BASE(qhat)
    q.trim()
    return q
```

**Пояснения шагов**

* **d = floor(b / (v[n-1] + 1))** — нормализует так, чтобы старший лимб v стал достаточно большим (главная идея для корректной оценки qhat).
* **qhat = ((u2 << 8) + u1) / v1** — берем два старших лимба u и делим на старший лимб v; это приближённая оценка частицы частного.
* **коррекция qhat** — проверка на случай переоценки (если `qhat * v2 > (rhat << 8) + u0`) и уменьшение `qhat` пока условие нарушено.
* **t = v * qhat << (i limbs)** — вычисление временного произведения и его сдвиг в позицию соответствующего значащего разряда.
* **если U < t**, значит qhat была слишком большой — уменьшаем и пересчитываем `t`.
* **u = u - t** — вычитаем скорректированную часть.

**Сложность**

* O(n*m) временно. Главная часть затрат — умножения `V * qhat` и вычитания больших чисел на каждом шаге.

### 8.5. Остаток от деления (BigNumber % BigNumber)

**Поведение**

* Можно получить, вычитая `q * v` из `u` после деления, либо реализовать отдельную версию, которая выполняет ту же логику, но возвращает остаток `u` в конце.
* После нормализации нужно "де-нормализовать" остаток: `r = u / d` (деление на d, где d — нормализующий множитель), если d != 1.

---

## 9. Алгоритм деления (алгоритм Кнута) — полный пошаговый разбор

Деление `u / v` (целочисленное) реализовано с использованием нормализации и оценки пробного частного q̂. Это адаптация Algorithm D (Knuth, The Art of Computer Programming).

### 9.1. Предварительные проверки

* Если делитель `v` равен нулю → ошибка.
* Если `v` имеет длину 1 (один лимб) → используем оптимизированное деление на `BASE` (`operator/(BASE)`).
* Если `u < v` → частное = 0.
* Если `u == v` → частное = 1.

### 9.2. Нормализация

* `b = BASENUM = 256`.
* n = len(v), m = len(u) - n.
* Вычисляем нормализующий множитель:
  [
  d = \left\lfloor \frac{b}{v_{n-1} + 1} \right\rfloor
  ]
  где `v_{n-1}` — старший лимб делителя.
* Умножаем `u` и `v` на `d`: `u = u * d`, `v = v * d`. Это гарантирует, что старший лимб `v` достаточно велик, упрощая оценку qhat.
* После умножения `u` может увеличиться в длине на 1 — в коде добавляют нулевой лимб, если нужно.

### 9.3. Основной цикл

* Инициализируем `q` длиной `m + 1` нулей.
* Для i от m до 0:
  * Гарантируем, что `u[i + n]` существует (добавляем нули, если надо).
  * Берём три старших лимба от `u` на позициях `i+n`, `i+n-1`, `i+n-2`: `u2`, `u1`, `u0`.
  * Берём два старших лимба делителя `v`: `v1 = v[n-1]`, `v2 = v[n-2]`.
  * Вычисляем пробное частное:
    [
    \hat{q} = \left\lfloor \frac{u2 \cdot b + u1}{v1} \right\rfloor,\quad
    \hat{r} = (u2 \cdot b + u1) \bmod v1.
    ]
  * Коррекция: пока (\hat{q} = b) или (\hat{q} \cdot v2 > \hat{r}\cdot b + u0), уменьшаем (\hat{q}) и увеличиваем (\hat{r}) на `v1`. Если `rhat >= b` — прерываем.
  * `t = v * qhat; t = t.Shift(i);` — умножение и сдвиг.
  * Если `u < t`, уменьшить `qhat` и пересчитать `t` (возможно, несколько раз).
  * `u = u - t; q.coefs[i] = (BASE)qhat;`.

### 9.4. Завершение

* Удаляем ведущие нули в `q`.
* `q` — результат деления.

### 9.5. Почему это корректно

* Нормализация обеспечивает требуемые свойства старших лимбов делителя, чтобы оценка qhat по двум старшим лимбам была допустимо близкой к истинному частному.
* Коррекция qhat по сравнению с проверкой на `v2` и `u0` устраняет переоценки.
* Метод даёт точное частное и остаток.

### 9.6. Сложность

* В худшем случае (O(n \cdot m)) (для каждого шага деления выполняются умножения/вычитания), где n = len(v), m = len(u)-n.

---

## 10. Ввод/вывод: hex и decimal — методы и замечания по эффективности

### 10.1. Hex-ввод/вывод

* `InputHex()` использует конструктор из строки.
* `OutputHex()` печатает старший лимб без ведущих нулей, остальные — с заполнением до 2 hex-символов.

**Пример `OutputHex()`**:

```cpp
void BigNumber::OutputHex(){
    int len = coefs.size();
    if (len == 0) { cout << "0\n"; return; }
    std::cout << std::hex << (unsigned int)coefs[len-1];
    for (int i=len-2; i>=0; i--){
        std::cout.width(BASE_SIZE/4);
        std::cout.fill('0');
        std::cout << std::hex << (unsigned int)coefs[i];
    }
    std::cout << std::dec << endl;
}
```

### 10.2. Decimal I/O (операторы `<<` и `>>`)

#### `operator>>` (ввод)

1. Операция читает последовательность символов из входного потока в строковую переменную.
2. Выполняется проверка: каждый символ строки рассматривается как символ десятичной цифры (`'0'..'9'`).
3. После валидации создаётся значение `other`, инициализируемое нулём.
4. Далее выполняется итерация по символам входной строки слева направо. Для каждого символа:
   * вычисляется числовое значение цифры: `digit = c - '0'`.
   * текущее значение `other` умножается на 10 и к результату прибавляется `digit`: `other = other * 10 + digit`.
5. По окончании прохода `other` содержит BigNumber, эквивалентный десятичной строке во входе.

#### `operator<<` (вывод)

```cpp
ostream& operator<< (ostream& out, const BigNumber& other){
    string output;
    BASE base_10 = 10;
    BigNumber number(other);
    BigNumber zeroNum;

    while (number != zeroNum){
        BASE tmp = (number % (BASE)base_10).coefs[0];
        output += (tmp + '0');
        number /= (BASE)base_10;
    }
    if (!output.size()) output = "0";
    reverse(output.begin(), output.end());
    cout << output << endl;
    return out;
}
```

**Шаги выполнения:**

1. Создаётся пустая строка `output`.
2. Создаётся рабочая копия `number` исходного `other`.
3. Инициализируется объект `zeroNum`, представляющий число 0.
4. Выполняется цикл `while (number != zeroNum)`:
   * вычисляется остаток от деления `number` на 10: `tmp = (number % (BASE)base_10).coefs[0]`.
   * полученное значение `tmp` преобразуется в символ и добавляется в конец строки `output`.
   * затем `number` делится на 10.
5. После выхода из цикла, если `output` пуст, присваивается строка `"0"`.
6. Выполняется `reverse(output.begin(), output.end())`.
7. Полученная строка выводится в поток.

---

## 11. Граничные случаи и обработка ошибок

### 11.1. Основные механизмы обработки ошибок

1. **Деление на ноль**: 
   - Для деления на `BASE` и `BigNumber`-делитель сделаны проверки
   - При обнаружении - вывод ошибки и выход

2. **Отрицательный результат при вычитании**: 
   - Выбрасывается `std::underflow_error`

3. **Некорректный ввод**:
   - Проверка hex-символов в конструкторе из строки
   - Проверка десятичных цифр в операторе ввода

4. **Удаление ведущих нулей**:
   - Выполняется после каждой операции для обеспечения корректности сравнений

### 11.2. Пример обработки ошибок

```cpp
BigNumber BigNumber::operator- (const BASE& num){
    // Проверка на отрицательный результат
    if (coefs.size() < 1 || (coefs.size() == 1 && coefs[0] < num)) 
        throw std::underflow_error("Negative result");
    // ... остальная реализация
}
```

---

## 12. Сложность алгоритмов (временная и пространственная)

### 12.1. Временная сложность

* Сложение / вычитание (BigNumber ↔ BigNumber): (O(n)), где (n) — число лимбов.
* Умножение (школьный): (O(n \cdot m)), (n) и (m) — длины операндов.
* Деление (алгоритм Кнута): (O(n \cdot m)) с большими константами (особенно из-за нормализации/коррекций).
* Decimal I/O (прямой метод деления на 10): потенциально (O(n^2)) или хуже из-за многократных делений.

### 12.2. Пространственная сложность

* Временные объекты при умножении могут аллоцировать до (n+m) лимбов.
* Деление использует нормализованные копии `u` и `v`, т.е. дополнительная память порядка длины операндов.
* Общая память — линейна по сумме длин операндов.

---

## 13. Тестирование и валидация

### 13.1. Существующие тесты в `main()`

В функции `main()` представлен комплексный тестовый сценарий:

1. **Генерация случайных чисел**: `BigNumber a(5)`
2. **Парсинг hex-строк**: `BigNumber b("1A3F9B")`  
3. **Копирование**: `c = b`
4. **Сравнения**: (`==`, `!=`, `>`, `<`, `>=`, `<=`)
5. **Арифметика с `BASE`**: `+`, `-`, `*`, `/`, `%`
6. **Арифметика с BigNumber**: `+`, `-`, `*`
7. **Граничные случаи**: умножение на 0, вычитание до 0, умножение на 1
8. **Ввод/вывод пользователем** (операторы `>>` и `<<`)

### 13.2. Методы тестирования

* Property-based тесты: генерация случайных `A` и `B` малых и средних длин и сверка результата с эталоном
* Тестирование крайних значений: лимбы равные 0, 255, длины 1, огромные длины, нули
* Юнит-тест: проверка инвариантов: `trim()` должен выполняться после каждой операции, `A == (A + 0)`, `A == (A * 1)`

---

## 14. Заключение

Реализованный класс `BigNumber` представляет собой robustную реализацию длинной арифметики в C++ на основе **base-256** (байтовой) репрезентации. Проект демонстрирует:

1. **Корректную реализацию** всех основных арифметических операций
2. **Эффективное использование памяти** через систему счисления с основанием 256
3. **Оптимизированные алгоритмы** для базовых операций
4. **Гибкий ввод/вывод** в различных системах счисления
5. **Обработку граничных случаев** и исключительных ситуаций

Ключевые достижения:
- Полное покрытие арифметических операций включая деление по алгоритму Кнута
- Эффективное использование типов данных для предотвращения переполнения
- Модульная архитектура, допускающая дальнейшие оптимизации

Данная реализация служит прочным фундаментом для приложений, требующих работы с числами произвольной точности - от образовательных проектов до серьезных криптографических и научных вычислений.
